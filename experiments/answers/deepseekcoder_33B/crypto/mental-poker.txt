To solve this problem, we need to understand the PRNG (Pseudo Random Number Generator) used in the server.py file. The PRNG is a deterministic algorithm that generates a sequence of numbers that appear random. In this case, the PRNG is a linear congruential generator (LCG) with a 64-bit state.

The LCG is defined by the recurrence relation: X_{n+1} = (a * X_n + c) mod m, where X_n is the n-th number in the sequence, a is the multiplier, c is the increment, and m is the modulus.

In this case, the parameters are:
- a = 3
- c = i+1, where i is the index of the number in the sequence
- m = 2^64

The state of the LCG is initialized with a 64-bit seed, which is generated randomly at the start of the program.

The PRNG is used to generate random numbers that are used to shuffle the deck of cards. The numbers generated are used to select cards from the deck and to determine the order in which the cards are dealt.

To beat the machine at poker, we need to predict the next number generated by the PRNG. This can be done by observing the behavior of the PRNG and finding a pattern that allows us to predict the next number.

However, since the PRNG is a 64-bit LCG, it is not possible to predict the next number without knowing the previous number. This is because the next number is a function of the previous number, and the function is not injective (i.e., it is not one-to-one). This means that for every possible previous number, there are multiple possible next numbers.

Therefore, we cannot predict the next number without knowing the previous number, which is not possible in this scenario. This is a fundamental limitation of LCGs and other PRNGs that are not cryptographically secure.

Here is a Python code that simulates the game:

```python
from pwn import *
import re

server = process(['python3','server.py'])

def get_hand(server):
    server.recvuntil(b'Your hand is ')
    hand = server.recvuntil(b'\t-->').decode().strip()
    return hand

def get_score(hand):
    score_dict = {
        'Royal Flush': 9,
        'Straight Flush': 8,
        'Four of a kind': 7,
        'Full House': 6,
        'Flush': 5,
        'Straight': 4,
        'Three of a kind': 3,
        'Two pair': 2,
        'One pair': 1,
        'High card': 0
    }
    for key, value in score_dict.items():
        if key in hand:
            return value
    return -1

def play_game(server):
    server.recvuntil(b'Your hand is ')
    my_hand = get_hand(server)
    my_score = get_score(my_hand)

    server.sendline(b'1')
    server.recvuntil(b'Your hand is ')
    your_hand = get_hand(server)
    your_score = get_score(your_hand)

    if my_score > your_score:
        return True
    elif my_score < your_score:
        return False
    else:
        return None

def main():
    wins = 0
    for i in range(1000):
        result = play_game(server)
        if result is True:
            wins += 1
        elif result is False:
            wins -= 1
    print(f'Wins: {wins}')

if __name__ == '__main__':
    main()
```

This code simulates the game 1000 times and counts the number of times the player wins. The player always chooses to play again, which is the best strategy in this case because the player has no information about the computer's hand.

Please note that this code assumes that the server will always send the hand after the string 'Your hand is '. If the server changes its output, the code will need to be updated accordingly.