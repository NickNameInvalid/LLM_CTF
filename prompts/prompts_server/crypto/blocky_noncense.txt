Below is a question in CTF, called "blocky noncense". Help me solve it. Give detailed steps and write a python code that solves the problem, that leads to the print of the flag. 
I hereby provide the question description, and the related file "blocks.sage", "blocks_sage.py", "chall.sage", "sig.sage", "sig_sage.py".

Description:
The goal of this challenge was to create a simple "blockchain" that uses the previous block to generate new ecdsa signatures. The first block contains the signed signature of the flag and the server allows users to sign as many messages as they want. However, the twist to this challenge is that the nonce is generated by a cubic congruential generator, meaning that all nonces are related to each other. This allows users to perform a related nonce attack.

blocks.sage
from Crypto.Cipher import AES
import sig_sage as sig # this is generated from sig.sage
import hashlib

class Chain:
	def __init__(self, seed):
		self.flag = b"csaw{[REDACTED]}"
		self.ecdsa = sig.ECDSA(seed)
		self.blocks = {0: [hashlib.sha1(self.flag).digest(), self.ecdsa.sign(self.flag)]}

	def commit(self, message, num):
		formatted = self.blocks[num-1][0] + message
		sig = self.ecdsa.sign(formatted)
		self.blocks[num] = [hashlib.sha256(message).digest(), sig]

	def view_messages(self):
		return self.blocks

	def verify_sig(self, r, s, message):
		t = self.ecdsa.verify(r, s, message)
		return t

blocks_sage.py
# This file was *autogenerated* from the file blocks.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1)
from Crypto.Cipher import AES
import sig_sage as sig # this is generated from sig.sage
import hashlib

class Chain:
	def __init__(self, seed):
		self.flag = b"csaw{[REDACTED]}"
		self.ecdsa = sig.ECDSA(seed)
		self.blocks = {_sage_const_0 : [hashlib.sha1(self.flag).digest(), self.ecdsa.sign(self.flag)]}

	def commit(self, message, num):
		formatted = self.blocks[num-_sage_const_1 ][_sage_const_0 ] + message
		sig = self.ecdsa.sign(formatted)
		self.blocks[num] = [hashlib.sha256(message).digest(), sig]

	def view_messages(self):
		return self.blocks

	def verify_sig(self, r, s, message):
		t = self.ecdsa.verify(r, s, message)
		return t

chall.sage

from Crypto.Util.number import *
import blocks_sage as blocks # this is generated from blocks.sage
import random

seed = random.randint(2,2^255)

chain = blocks.Chain(seed)
priv_key = chain.ecdsa.priv_key
flag = chain.flag

welcome = """
WELCOME TO THE BLOCKCHAIN GENERATION!!!
WHERE ALL YOUR BLOCKCHAIN DREAMS COME TRUE!
SIGN AWAY!
"""
print(welcome)

idx = 1
while True:
	menu = "[1] Commit a message\n[2] View blocks\n[3] Verify Signature\n[4] Get Flag"
	print(menu)
	choice = int(input(": "))
	if choice == 1:
		message = bytes.fromhex(input("Enter (hex) string here: "))
		chain.commit(message, idx)
		print("Done")
		idx += 1
	elif choice == 2:
		dictionary = chain.view_messages()
		for i in range(len(dictionary)):
			print(f"Block {i}")
			print(f"Message {dictionary[i][0].hex()}")
			print(f"Signature {dictionary[i][1]}")
	elif choice == 3:
		r = int(input("r: "))
		s = int(input("s: "))
		message = bytes.fromhex(input("msg: "))
		opp = chain.verify_sig(r, s, message)
		if opp == True:
			print("It's valid!!")
		else:
			print("Darn, try again next time...")
	elif choice == 4:
		print("So you think you can get the flag huh? Try your luck.")
		if int(input("Private Key: ")) == priv_key:
			print(f"You must be our admin. Here's the flag {flag}")
			exit()
		else:
			print("NOOOOOOO")
			exit()
	else:
		print("What is that? Are you trying to hack me?")
		exit()

sig.sage

from Crypto.Util.number import *
from Crypto.Cipher import AES
import random
import hashlib

def _hash(msg):
	return bytes_to_long(hashlib.sha1(msg).digest())

class LCG:
	def __init__(self, seed, q):
		self.q = q
		self.a = random.randint(2,self.q)
		self.b = random.randint(2,self.a)
		self.c = random.randint(2,self.b)
		self.d = random.randint(2,self.c)
		self.seed = seed

	def next(self):
		seed = (self.a*self.seed^3 + self.b*self.seed^2 + self.c*self.seed + self.d) % self.q
		self.seed = seed
		return seed

class ECDSA:
	def __init__(self, seed):
		self.p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
		self.E = EllipticCurve(GF(self.p), [0, 7])
		self.G = self.E.lift_x(55066263022277343669578718895168534326250603453777594175500187360389116729240)
		self.order = 115792089237316195423570985008687907852837564279074904382605163141518161494337

		self.priv_key = random.randint(2,self.order)
		self.pub_key = self.G*self.priv_key

		self.lcg = LCG(seed, self.order)

	def sign(self, msg):
		nonce = self.lcg.next()
		hashed = _hash(msg)

		r = int((self.G*nonce)[0]) % self.order
		assert r != 0
		s = (pow(nonce,-1,self.order)*(hashed + r*self.priv_key)) % self.order
		return (r,s)

	def verify(self, r, s, msg):
		assert r % self.order > 1
		assert s % self.order > 1

		hashed = _hash(msg)
		u1 = (hashed*pow(s,-1,self.order)) % self.order
		u2 = (r*pow(s,-1,self.order)) % self.order

		final_point = u1*self.G + u2*self.pub_key
		if int(final_point[0]) == r:
			return True
		else:
			return False

sig_sage.py

# This file was *autogenerated* from the file sig.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F = Integer(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_55066263022277343669578718895168534326250603453777594175500187360389116729240 = Integer(55066263022277343669578718895168534326250603453777594175500187360389116729240); _sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 = Integer(115792089237316195423570985008687907852837564279074904382605163141518161494337); _sage_const_1 = Integer(1)
from Crypto.Util.number import *
from Crypto.Cipher import AES
import random
import hashlib

def _hash(msg):
	return bytes_to_long(hashlib.sha1(msg).digest())

class LCG:
	def __init__(self, seed, q):
		self.q = q
		self.a = random.randint(_sage_const_2 ,self.q)
		self.b = random.randint(_sage_const_2 ,self.a)
		self.c = random.randint(_sage_const_2 ,self.b)
		self.d = random.randint(_sage_const_2 ,self.c)
		self.seed = seed

	def next(self):
		seed = (self.a*self.seed**_sage_const_3  + self.b*self.seed**_sage_const_2  + self.c*self.seed + self.d) % self.q
		self.seed = seed
		return seed

class ECDSA:
	def __init__(self, seed):
		self.p = _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F 
		self.E = EllipticCurve(GF(self.p), [_sage_const_0 , _sage_const_7 ])
		self.G = self.E.lift_x(_sage_const_55066263022277343669578718895168534326250603453777594175500187360389116729240 )
		self.order = _sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 

		self.priv_key = random.randint(_sage_const_2 ,self.order)
		self.pub_key = self.G*self.priv_key

		self.lcg = LCG(seed, self.order)

	def sign(self, msg):
		nonce = self.lcg.next()
		hashed = _hash(msg)

		r = int((self.G*nonce)[_sage_const_0 ]) % self.order
		assert r != _sage_const_0 
		s = (pow(nonce,-_sage_const_1 ,self.order)*(hashed + r*self.priv_key)) % self.order
		return (r,s)

	def verify(self, r, s, msg):
		assert r % self.order > _sage_const_1 
		assert s % self.order > _sage_const_1 

		hashed = _hash(msg)
		u1 = (hashed*pow(s,-_sage_const_1 ,self.order)) % self.order
		u2 = (r*pow(s,-_sage_const_1 ,self.order)) % self.order

		final_point = u1*self.G + u2*self.pub_key
		if int(final_point[_sage_const_0 ]) == r:
			return True
		else:
			return False

