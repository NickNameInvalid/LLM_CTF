

# This file was *autogenerated* from the file sig.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F = Integer(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_55066263022277343669578718895168534326250603453777594175500187360389116729240 = Integer(55066263022277343669578718895168534326250603453777594175500187360389116729240); _sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 = Integer(115792089237316195423570985008687907852837564279074904382605163141518161494337); _sage_const_1 = Integer(1)
from Crypto.Util.number import *
from Crypto.Cipher import AES
import random
import hashlib

def _hash(msg):
	return bytes_to_long(hashlib.sha1(msg).digest())

class LCG:
	def __init__(self, seed, q):
		self.q = q
		self.a = random.randint(_sage_const_2 ,self.q)
		self.b = random.randint(_sage_const_2 ,self.a)
		self.c = random.randint(_sage_const_2 ,self.b)
		self.d = random.randint(_sage_const_2 ,self.c)
		self.seed = seed

	def next(self):
		seed = (self.a*self.seed**_sage_const_3  + self.b*self.seed**_sage_const_2  + self.c*self.seed + self.d) % self.q
		self.seed = seed
		return seed

class ECDSA:
	def __init__(self, seed):
		self.p = _sage_const_0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F 
		self.E = EllipticCurve(GF(self.p), [_sage_const_0 , _sage_const_7 ])
		self.G = self.E.lift_x(_sage_const_55066263022277343669578718895168534326250603453777594175500187360389116729240 )
		self.order = _sage_const_115792089237316195423570985008687907852837564279074904382605163141518161494337 

		self.priv_key = random.randint(_sage_const_2 ,self.order)
		self.pub_key = self.G*self.priv_key

		self.lcg = LCG(seed, self.order)

	def sign(self, msg):
		nonce = self.lcg.next()
		hashed = _hash(msg)

		r = int((self.G*nonce)[_sage_const_0 ]) % self.order
		assert r != _sage_const_0 
		s = (pow(nonce,-_sage_const_1 ,self.order)*(hashed + r*self.priv_key)) % self.order
		return (r,s)

	def verify(self, r, s, msg):
		assert r % self.order > _sage_const_1 
		assert s % self.order > _sage_const_1 

		hashed = _hash(msg)
		u1 = (hashed*pow(s,-_sage_const_1 ,self.order)) % self.order
		u2 = (r*pow(s,-_sage_const_1 ,self.order)) % self.order

		final_point = u1*self.G + u2*self.pub_key
		if int(final_point[_sage_const_0 ]) == r:
			return True
		else:
			return False

